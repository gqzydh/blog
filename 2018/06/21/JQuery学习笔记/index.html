<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="前端博客">
  <meta name="keywords" content="web前端, Web, 前端开发, 前端博客">
  
    <link rel="icon" href="/images/favicon_16X16.ico">
  
  
  <title>JQuery学习笔记 | 前端博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.css" /> -->
</head>

<body>
  <header>
  <div class="header-container">
    <a class='logo' href="/">
      <span>前端博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id='post'>
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>JQuery学习笔记</h1>
          <div class='post-meta'>
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2018年06月21日</time>
            
              | <i class="fa fa-folder-open-o" aria-hidden="true"></i> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/jQuery/">jQuery</a>
  </div>



            
            
              | 
                  <i class="fa fa-tags" aria-hidden="true"></i>
                
               
  <a href="/tags/#jQuery" class='tag'>jQuery</a>

  <a href="/tags/#笔记" class='tag'>笔记</a>


            
          </div>
          <p>jQuery大部分功能需要根据文档的DOM模型来工作，首先需要正确地解析到整个文档的DOM模型结构。使用jQuery需要在整个文档被浏览器完全加载后才开始进行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(document).ready(function () &#123;</span><br><span class="line">    alert(&quot;Hello World!&quot;);</span><br><span class="line">    $(&quot;p&quot;).click(function (event) &#123;</span><br><span class="line">        alert(&quot;Thanks for visiting!&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>$是在jQuery中使用的变量名，可以使用jQuery.noConflict()避免冲突，它的返回值就是jQuery对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line">$j = jQuery.noConflict();</span><br></pre></td></tr></table></figure></p>
<p>jQuery对象与DOM对象之间的转换</p>
<p>使用$()得到的是一个jQuery对象。它封装了很多 DOM 对象的操作，但是它和 DOM 对象之间是不同的。只有当obj是一个DOM对象时才能使用obj.innerHTML；相应地，如果是jQuery对象应该使用 obj.html() 。</p>
<p>从 DOM 对象转到 jQuery 对象： $(obj)<br>从 jQuery 对象转到 DOM 对象： obj[0]</p>
<p>比较正规地从 jQuery 对象到 DOM 的转换，是使用 jQuery 对象的 get() 方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function () &#123;</span><br><span class="line">    $(&quot;li&quot;).get();</span><br><span class="line">    $(&quot;li&quot;).get(0);</span><br><span class="line">    $(&quot;li&quot;).get(-1);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h2><h3 id="常规选择器"><a href="#常规选择器" class="headerlink" title="常规选择器"></a>常规选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;*&quot;) 选择所有节点</span><br><span class="line">$(&quot;#id&quot;) ID选择器，注意其中的一些特殊字符，如.</span><br><span class="line">$(&quot;.class&quot;) 类选择器</span><br><span class="line">$(&quot;tag&quot;) 标签选择器</span><br><span class="line">$(&quot;子元素&quot;)</span><br><span class="line">$(&quot;直接子元素&quot;)</span><br><span class="line">:focus 获取焦点元素</span><br><span class="line">:first-child/:last-child 选择第一个/最后一个元素</span><br><span class="line">:first/:last 截取第一个/最后一个符合条件的元素</span><br><span class="line">(&quot;pre+next&quot;) 直接兄弟元素</span><br><span class="line">(&quot;pre~siblings&quot;) 兄弟元素</span><br><span class="line">:nth-child() 索引选择，索引从1开始</span><br><span class="line">:nth-child(odd)</span><br><span class="line">:nth-child(even)</span><br><span class="line">:nth-child(4n)</span><br></pre></td></tr></table></figure>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[name~=&quot;value&quot;] 属性中包括某单词</span><br><span class="line">[name=&quot;value&quot;] 属性完全等于指定值</span><br><span class="line">[name!=&quot;value&quot;] 属性不等于指定值</span><br><span class="line">[name] 包括有指定属性的元素</span><br></pre></td></tr></table></figure>
<h3 id="控件选择器"><a href="#控件选择器" class="headerlink" title="控件选择器"></a>控件选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:checked 选择所有被选中的元素</span><br><span class="line">:selected 被选择的元素</span><br><span class="line">:disabled/:enabled 选择被禁用/未禁用的元素</span><br><span class="line">:hidden 隐藏元素，不仅是[type=&quot;hidden&quot;]，还有displa:none</span><br><span class="line">:visible 可见控件，visibility:hidden和opacity:0同样被认为是可见</span><br><span class="line">:input :button :checkbox :file :image :password :radio :reset :submit :text 具体控件，图像控件是[type=&quot;image&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[name=&quot;value&quot;] [name2=&quot;value2&quot;] 多个AND条件</span><br><span class="line">(&quot;selector1, selector2, selectorN&quot;) 多个OR条件</span><br><span class="line">:not() 否定选择</span><br><span class="line">(&apos;:contains(&quot;text&quot;)&apos;) 包含有指定内容的元素</span><br><span class="line">:eq() :lt() :gt() :even :odd 列表索引选择（不支持负数）</span><br><span class="line">(&apos;:has(selector)&apos;) 符合条件的再次过滤</span><br><span class="line">:header 选择h1,h2,h3...标题元素</span><br><span class="line">:only-child 仅有一个子元素的元素</span><br><span class="line">:empty 空元素，即无内容也无元素</span><br><span class="line">:parent 非空元素</span><br></pre></td></tr></table></figure>
<h2 id="节点漫游"><a href="#节点漫游" class="headerlink" title="节点漫游"></a>节点漫游</h2><h3 id="调用链处理"><a href="#调用链处理" class="headerlink" title="调用链处理"></a>调用链处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.add() 向已有的节点序列中添加新的对象</span><br><span class="line">.andSelf() 在调用链中，随时加入原始序列</span><br><span class="line">.eq() 指定索引选取节点，支持负数</span><br><span class="line">.filter() .is() .not() .find() .first() .last() .has() 序列选择</span><br><span class="line">.end() 节点回溯</span><br><span class="line">$(function () &#123;</span><br><span class="line">    $(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;)</span><br><span class="line">        .end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p>.children() 所有的子节点，可加入过滤条件，.children(selector)</p>
<h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><p>.siblings() .next() .nextAll() .nextUntil() .prevAll() .prevUntil() .closet() 选择兄弟节点</p>
<h3 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h3><p>.parent() .parents() .parentUntil() 父节点选择</p>
<h2 id="元素控制"><a href="#元素控制" class="headerlink" title="元素控制"></a>元素控制</h2><h3 id="attributes和properties的区别"><a href="#attributes和properties的区别" class="headerlink" title="attributes和properties的区别"></a>attributes和properties的区别</h3><p>attributes 是XML结构中的属性节点</p>
<p><div onload="prettyPrint()"></div><br>properties 是DOM对象，对象属性<br>$(‘body’).get(0).tagName;</p>
<h3 id="类与属性控制"><a href="#类与属性控制" class="headerlink" title="类与属性控制"></a>类与属性控制</h3><p>.addCLass() .hasClass() .removeClass() 添加一个类，判断是否有指定类，删除类<br>$(‘body’).addClass(‘test’);<br>$(‘body’).addClass(function (index, current) {<br>    return current + ‘new’;<br>});<br>$(‘body’).removeClass(‘test’);<br>$(‘body’).removeClass(function (index, current) {<br>    return current + ‘ ‘ + ‘other’;<br>});<br>.toggleClass() 类的开关式转换<br>$(‘img’).toggleClass(); //对所有类的开关<br>$(‘img’).toggleClass(‘test’); //对指定类的开关<br>$(‘img’).toggleClass(isTrue); //根据<code>isTrue</code>判断所有类的开关<br>$(‘img’).toggleClass(‘test’, isTrue); //根据<code>isTrue</code>判断指定类的开关</p>
<p>//同 <code>$(&#39;img&#39;).toggleClass(&#39;test&#39;);</code> 只是类名由函数返回<br>$(‘img’).toggleClass(function (index, className, isTrue) {<br>    return ‘name’<br>});</p>
<p>// <code>isTrue</code>作为函数的第三个参数传入<br>$(‘img’).toggleClass(function (index, className, isTrue) {<br>    return ‘name’<br>}, isTrue);<br>.attr() 获取或设置一个属性值<br>// $(“#greatphoto”).attr(‘alt’); //获取属性<code>$(&quot;#greatphoto&quot;).attr(&#39;alt&#39;, &#39;Shenzhen Brush Seller&#39;); //设置属性</code></p>
<p>// 同时设置多个属性<br>$(‘#greatphoto’).attr({<br>    alt: ‘Shen Brush Seller’,<br>    title: ‘photo by Kelly Clark’<br>});</p>
<p>//设置属性为函数返回值，函数的上下文为当前元素<br>$(‘#greatphoto’).attr(‘title’, function (i, val) {<br>    return val + ‘ - photo by Kelly Clark’;<br>})<br>.prop() 用法同.attr()，只是对象变成了properties<br>.removeAttr() .removeProp() 删除属性<br>.val() 设置或获取元素的表单值，通常用于表单元素<br>$(‘input’).val();<br>$(‘input’).val(‘other’);<br>.html() 设置或获取元素的节点html<br>$(‘div’).html();<br>$(‘div’).html(‘<div>测试</div>‘);<br>$(‘div’).html(function (index, old) {<br>    return old + ‘<span>另外的内容</span>‘;<br>});</p>
<h3 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h3><p>.css() 获取或设置指定的CSS样式<br>$(‘body’).css(‘background-color’, ‘red’);<br>$(‘body’).css(‘background-color’, function (index, value) {<br>    return value + ‘1’;<br>});<br>$(‘body’).css({color: ‘green’, ‘background-color’: ‘red’});<br>.width() .height() 获取或设置元素的宽和高<br>$(‘body’).width();<br>$(‘body’).width(50);<br>$(‘body’).width(function (index, value) {<br>    return value += 10;<br>})<br>.innerWidth() .innerHeight() .outerHeight() .outerWidth() 元素的其他尺寸值<br>.scrollLefgt() .scrollTop() 获取或设置滚动条的位置<br>.offset() .position() 获取元素的坐标<br>offset是相对于document，position是相对于父级元素<br>结构控制</p>
<ol>
<li>文本节点</li>
</ol>
<p>.html() .text() 设置和获取节点的文本值。设置时.text()会转义标签，获取时.text()会移除所有标签。</p>
<ol>
<li>子节点</li>
</ol>
<p>.append() .prepend()<br>$(‘.inner’).append(‘</p><p>Test</p>‘);<br>参数可以有多种形式：<p></p>
<p>var $newdiv1 = $(‘<div id="object1">‘),<br>    newdiv2 = document.createElement(‘div’),<br>    existingdiv1 = document.getElementById(‘foo’);</div></p>
<p>$(‘body’).append($newdiv1, [newdiv2, existingdiv1]);</p>
<ol>
<li>兄弟节点</li>
</ol>
<p>.after() .before()<br>$(‘.inner’).after(‘</p><p>Test</p>‘);<p></p>
<ol>
<li>父节点</li>
</ol>
<p>.wrap() .wrap() .wrapInner()<br>$(‘.inner’).wrap(‘<div class="new"></div>‘);<br>$(‘.inner’).wrapAll(‘<div class="new"></div>‘);<br>$(‘.inner’).wrapInner(‘<div class="new"></div>‘);</p>
<ol>
<li>复制/删除/替换节点</li>
</ol>
<p>.clone() 复制节点，可选参数表示是否处理已绑定的事件与数据<br>.clone(true) 处理当前节点的事件与数据<br>.clone(true, true) 处理当前节点及所有子节点的事件与数据<br>.detach() 暂时移除节点，之后可以再次恢复指定位置<br>.remove() 永久移除节点<br>.empty() 清除一个节点的所有内部内容<br>.unwrap() 移除节点的父节点<br>工具函数<br>.map() 遍历所有成员<br>$(‘:checkbox’).map(function () {<br>    return this.id;<br>}).get().join(‘,’);</p>
<p>$(‘:checkbox’).map(function (index, node) {<br>    return node.id;<br>}).get().join(‘,’);<br>.slice() 序列切片，支持一个或两个参数，支持负数<br>$(‘li’).slice(2).css(‘background-color’, ‘red’);<br>$(‘li’).slice(2, 4).css(‘background-color’, ‘green’);<br>$(‘li’).slice(-2, -1).css(‘background-color’, ‘blue’);<br>通用工具<br>$.each() $.map() 遍历列表，$.map()可以用于对象<br>$.each([52, 97], function (index, value) {<br>    console.log((index + ‘ : ‘ + value));<br>});<br>$.map([0, 1, 2], function (index, n) {<br>    return n + 4;<br>});<br>$.map([0, 1, 2], function (n) {<br>    return n &gt; 0 ? n + 1 : null;<br>});<br>$.map([0, 1, 2], function (n) {<br>    return [n, n + 1];<br>});</p>
<p>var dimensions = {width: 10, height: 15, length: 20};<br>$.map(dimensions, function (value, key) {<br>    return value * 2;<br>});</p>
<p>var dimensions = {width: 10, height: 15, length: 20};<br>$.map(dimensions, function (value, key) {<br>    return key;<br>});<br>$.extend() 合并对象，第一个参数表示是否进行递归深入<br>var object = $.extend({}, object1, object2);<br>var object = $.extend(true, {}, object1, object2);<br>$.merge() 合并列表<br>$.merge([0, 1, 2], [2, 3, 4]);<br>.grep() 过滤列表，第三个参数表示是否为取反<br>$.grep([0, 1, 2], function (array, index) {<br>    return n &gt; 0;<br>});//[1,2]<br>$.grep([0, 1, 2], function (array, index) {<br>    return n &gt; 0;<br>}, true);//[0]<br>$.inArray() 存在判断<br>$.inArray(value, array [, fromIndex])<br>$.isArray() $.isEmptyObject() $.isFunction() $.iSNumeric() $.isPainObject() $.isWindow $.isXMLDoc() 类型判断<br>$.noop() 空函数<br>$.now() 当前时间戳，值为(new Date).getTime()<br>$.parseJson() $.parseXML() 把字符串解析为对象<br>var xml = “<rss version="2.0"><channel><title>RSS Title</title></channel></rss>“,<br>    xmlDoc = $.parseXML(xml),<br>    $xml = $(xmlDoc),<br>    $title = $xml.find(“title”);<br>$.trim() 去头去尾 $.trim(str)<br>$.type() 判断参数的类型<br>$.unique() 遍历后去重。$.unique(arraty)<br>上下文绑定<br>$.proxy() 为函数绑定上下文<br>$.proxy(function,context)<br>$.proxy(context,name)<br>var o = {<br>    x: ‘123’,<br>    f: function () {<br>        console.log(this.x)<br>    },<br>};<br>var go = function (f) {<br>    f()<br>};</p>
<p>o.f();// 123<br>go(o.f);// undefined<br>go($.proxy(o.f, o));//123<br>$.proxy(o, ‘f’)(); //123<br>当一个函数被传递之后，它就失去了原先的上下文。</p>
<p>把数据存到节点中<br>jQuery提供了一种机制，可以把节点作为数据存储的容器。</p>
<p>$.data() 往节点中获取/设置数据<br>$.removeData() 删除数据<br>在内部实现上，jQuery会在指定节点添加一个内部标识，以此为key，把数据存在内部闭包的一个结构中。</p>
<p>事实上，jQuery的事件绑定机制也使用了这套数据接口。</p>
<p>$.data($(‘#data’).get(0), ‘test’, ‘123’);<br>$(‘#data’).data(‘test’, ‘456’);<br>事件处理</p>
<ol>
<li>事件绑定</li>
</ol>
<p>在 jQuery1.7之后，推荐统一使用on()来进行事件绑定。</p>
<p>.on() 绑定事件 on()的基本使用方式是：.on(event,handler)<br>.off() 移除事件<br>.one() 绑定单次事件<br>$(‘#btn’).on(‘click’, function (eventObj) {<br>    console.log(‘Hello’);<br>})<br>对于handler，它默认的上下文是触发事件的节点：</p>
<p>$(‘#btn’).on(‘click’, function (eventObj) {<br>    console.log(this);<br>})<br>使用$.proxy()可以随意控制上下文：</p>
<p>$(‘#btn’).on(‘click’,<br>    $.proxy(function (eventObj) {<br>        console.log(this.a);<br>    }, {a: 123})); // 123<br>event参数还支持通过：</p>
<ul>
<li>以<code>.</code>分割的子名字</li>
<li>以空格分割的多个事件<br>$(‘#btn’).on(‘click.my’, (function (eventObj) {<pre><code>    console.log(&apos;123&apos;);
}
</code></pre>  )<br>);<br>var f = function () {<br>  $(‘#btn’).off(‘click.my’)<br>};<br>多个事件：</li>
</ul>
<p>$(‘#btn’).on(‘click.my click.other’,<br>    (function (eventObj) {<br>            console.log(‘123’);<br>        }<br>    )<br>);<br>var f = function () {<br>    $(‘#btn’).off(‘click.my’)<br>}<br>on()的另一种调用形式：</p>
<p>$(‘#btn’).on({<br>    ‘click’: function (eventObj) {<br>        console.log(‘click’);<br>    },<br>    ‘mousemove’: function (eventObj) {<br>        console.log(‘move’);<br>    }<br>});<br>off()的使用方式与on()完全类似：</p>
<p>var f = function (eventObj) {<br>    console.log(‘Hello’);<br>};<br>$(‘#btn’).on(‘click’, f);<br>$(‘#btn’).off(‘click’);</p>
<ol>
<li>事件触发</li>
</ol>
<p>事件的触发有两种方式，一是使用预定的“事件函数”（.click()，.focus()），二是使用trigger()或triggerHandler()。</p>
<p>$(‘#btn’).on(‘click’, function (eventObj) {<br>    console.log(“hello”);<br>});<br>$(‘#btn’).click();<br>$(‘#btn’).trigger(‘click’);<br>trigger()与triggerHandler()不同之处在于前面是触发事件，而后者是执行绑定函数。</p>
<p>$(‘#btn’).on(‘focus’, function (event) {<br>    console.log(“Hello”);<br>});<br>$(‘#btn’).triggerHandler(‘focus’);<br>trigger()和triggerHandler()也用于触发自定义事件。</p>
<p>$(‘#btn’).on(‘my’, function (event) {<br>    console.log(“Hello”);<br>});<br>$(‘#btn’).triggerHandler(‘my’);<br>trigger()和triggerHandler()触发事件时，可以带上参数：</p>
<p>$(‘#btn’).on(‘my’, function (event) {<br>    console.log(obj);<br>});<br>$(‘#btn’).trigger(‘my’, {a: 123});</p>
<ol>
<li>事件类型</li>
</ol>
<p>行为事件：</p>
<p>.click() 单击<br>.dbclick() 双击<br>.blur() 失去焦点时<br>.change() 值变化时<br>.focus() 获取焦点时<br>.focusin() jQuery扩展的获取焦点<br>.focusout() jQuery扩展的失去焦点<br>.resize() 调整大小<br>.scroll() 滚动<br>.select() 被选择<br>.submit() 表单被提交<br>键盘事件：</p>
<p>.keydown() 按下键<br>.keyup() 放开键<br>鼠标事件：</p>
<p>.mousedown() 点下鼠标<br>.mouseup() 松开鼠标<br>.mouseover() 光标移入<br>.mouseout() 光标移出<br>.mousemove() 光标在其上移动<br>.mouseleave() .mouseenter() 光标移出/移入<br>页面事件：</p>
<p>.ready() 准备就绪<br>.unload() 离开当前页时，针对window对象<br>.error() 发生错误时<br>.load() 正在载入</p>
<ol>
<li>事件对象</li>
</ol>
<p>event.currentTarget,event,target 事件绑定节点/事件的触发节点（冒泡行为）<br>event.delegateTarget 绑定事件的对象，通常就是event.currentTarget<br>event.relatedTarget 相关的节点，主要用于一些转换式的事件。比如鼠标移入，表示它从哪个节点来的<br>event.which 标明哪个按钮触发了事件，鼠标和键盘的键标识统一在这个属性中<br>event.preventDefault() event.isDefaultPrevented() 禁止默认行为<br>event.stopImmediateProgation() event.isImmediateProgationStopped() 不仅禁止冒泡。还终止绑定函数链的继续进行<br>event.stopPropagation()，event.isPropagationStopped() 禁止冒泡<br>event.pageX，event.pageY 事件触发时相对于document的鼠标位置<br>event.namespace 事件触发时的名字空间，比如trigger(‘click.namespace’)<br>event.data 额外传入的数据<br>event.result 上一个绑定函数的返回值<br>event.timeStamp 事件触发时的时间，其值为(new Date).getTime()<br>event.type 事件类型<br>如果一个绑定函数最后返回了false，则默认是event.preventDefault()和event.stopPropagation()行为。</p>
<p>AJAX</p>
<ol>
<li>请求与回调</li>
</ol>
<p>jQuery的AJAX，核心的请求处理函数只有一个，就是$.ajax()，然后就是一个简单的上层函数。</p>
<p>$.ajax() 的基本使用形式是：</p>
<p>jQuey.ajax(settings) settings是一个对象，里面包含了所有的配置项。</p>
<p>url 请求的地址。<br>type 请求的方法类型，GET，POST。默认是GET。<br>data 要发送的数据<br>dataType 服务器返回的数据类型，支持xml，html，script，json，jsonp，text<br>success 请求成功时调用的处理函数 success(data, textStatus, jqXHR)<br>context 回调函数执行时的上下文<br>cache 默认为true，是否为请求单独添加一个随机参数以防止浏览器缓存<br>error 请求错误时的调用函数。<br>error(jqXHR, textStatus, errorThrown)<br>第二个参数是表示请求状态的字符串：timeout，error，abort，parsererror<br>第三个参数是当HTTP错误发生时，具体的错误描述：Not Found，Internal Server Error等<br>complete 请求结束（无论成功或失败）时的一个回调函数。<br>complete(jqXHR, textStatus)<br>第二个参数时表示请求状态的字符串：success，notmodified，error，timeout，abort，parsererror。<br>jsonp 一个参数名，默认是callback，一般用于指明回调函数名。设置成false可以让请求没有callback参数。<br>jsonpCallback callback参数值。默认是自动生成的一个随机值。</p>
<ol>
<li>请求的状态</li>
</ol>
<p>对于全局的所有AJAX请求而言，可以在任意节点上绑定到全局任意AJAX请求的每一个事件：</p>
<p>$(‘#loading’).ajaxStart(function () {<br>    $(this).show();<br>});<br>.ajaxStart() 请求将要发出时<br>.ajaxSend() 请求将要发出时（在.ajaxStart()后）<br>.ajaxSuccess() 请求成功<br>.ajaxError() 请求错误<br>.ajaxComplete() 请求完成<br>.ajaxStop() 请求结束（在.ajaxComplete()后）</p>
<ol>
<li>工具函数</li>
</ol>
<p>.serialize() 解析表单参数项，返回字符串<br>$(‘form’).submit(function () {<br>    alert($(this).serialize());<br>    return false;<br>});<br>.serializeArray() 解析表单参数项，返回一个列表对象。<br>$(‘form’).submit(function () {<br>    alert($(this).serializeArray());<br>    return false;<br>});<br>泛化回调</p>
<ol>
<li>Deferred</li>
</ol>
<p>Deferred对象是在jQuery1.5中引入的回调管理对象。其作用是把一堆函数按顺序放入一个调用链，然后根据状态来依次调用这些函数。AJAX的所有操作都是使用它来进行封装的。<br>var obj = $.Deferred(function (a) {</p>
<p>});<br>obj.done(function () {<br>    console.log(“1”);<br>});<br>obj.done(function () {<br>    console.log(“2”);<br>});<br>obj.resolve();<br>总的来说：jQuery的Deferred对象有三个状态：done，fail，process。</p>
<ul>
<li><code>process</code> 只能先于其他两个状态先被激发。</li>
<li><code>done</code>和<code>fail</code>互斥，只能激发一个。</li>
<li><code>process</code>可以被重复激发，而<code>done</code>和<code>fail</code>只能激发一次。<br>然后，jQuery提供了一些函数用于添加回调，激发状态等。</li>
</ul>
<p>deferred.done() 添加一个或多个成功回调<br>deferred.fail() 添加一个或多个失败回调<br>deferred.always() 添加一个函数，同时应用于成功和失败<br>deferred.progress() 添加一个函数用于准备回调<br>deferred.then() 依次接受三个函数，分别用于成功，失败，准备状态<br>deferred.reject() 激发失败状态<br>deferred.resolve() 激发成功状态<br>deferred.notify() 激发准备状态<br>如果一个Deferred已经被激发，则新添加的对应的函数会被立即执行。</p>
<p>jQuery还提供了一个jQuery.when()的回调管理函数，可以用于方便地管理多个事件并发的情况。</p>
<p>var defer = $.ajax({<br>    url: ‘test.html’,<br>    dataType: ‘json’<br>});<br>defer.done(function (data) {<br>    console.log(data);<br>});<br>done()做的事和使用success()定义是一样的。</p>
<p>当我们需要完成，像“请求A和请求B都完成时，执行函数”之类的需求时，使用$.when()就可以了。</p>
<p>var defer_1 = $.ajax({<br>    url: ‘json.html’,<br>    dataType: ‘json’<br>});<br>var defer_2 = $.ajax({<br>    url: ‘jsonp.html’,<br>    dataType: ‘jsonp’<br>});<br>var new_defer = $.when(defer_1, defer_2);<br>new_defer.done(function () {<br>    console.log(“hello”);<br>});<br>在$.when()中的Deferred，只要有一个是fail，则整体结果为fail。</p>
<p>Deferred的回调函数的执行顺序与它们的添加顺序一致。</p>
<p>这里特别注意一点，就是done/fail/always与then的返回值的区别。从功能上看，它们都可以添加回调函数，但是，方法的返回值是不同的。前组的返回值是原来的那个defer对象，而then返回的是一个新的defer对象。</p>
<p>then返回新的defer这种形式，可以用于方便地实现异步函数的链式调用。</p>
<p>defer.done(function () {<br>    return $.ajax({<br>        url: ‘/json’,<br>        dataType: ‘json’,<br>        success: function () {<br>            console.log(“inner”);<br>        }<br>    })<br>}).done(function () {<br>    console.log(“hello”);<br>});<br>等同于是调用了两次 defer.done, defer.done ，注册的两次回调函数依次被执行后，看到的输出是：hello，inner。</p>
<p>这是两次 defer.done 的结果，第一个回调函数返回了一个新的 defer 没任何作用。</p>
<p>如果换成 then 方法：defer.then(function () {…});</p>
<p>它跟两次 defer.done 是不同的。 new_defer 会在 inner 那里的 defer 被触发时再被触发，所以输出结果是：inner，hello。</p>
<p>更一般地来说 then 的行为，就是前面的注册函数的返回值，会作为后面注册函数的参数值：</p>
<p>var defer = $.ajax({<br>    url: ‘/json’,<br>    dataType: ‘json’<br>});<br>defer.then(function (res) {<br>    console.log(res);<br>    return 1;<br>}).then(function (res) {<br>    console.log(res);<br>    return 2;<br>}).then(function (res) {<br>    console.log(res);<br>});<br>上面代码的输入结果是：ajax response，1，2。</p>
<ol>
<li>Callbacks</li>
</ol>
<p>事实上，Deferred机制，只是在Callbacks机制的上层进行了一层简单封装。Callbacks对象才是真正的jQuery中定义的原始的回调管理机制。</p>
<p>var obj = $.Callbacks();<br>obj.add(function () {<br>    console.log(“1”);<br>});<br>obj.add(function () {<br>    console.log(“2”);<br>});<br>obj.fire();<br>Callbacks对象的初始化支持一组控制参数：</p>
<p>$.Callbacks(flags) 初始化一个回调管理对象。flags是空格分割的多个字符串，以定义此回调对象的行为：<br>once 回调链只能被激发一次<br>memory 回调链被激发后，新添加的函数被立即执行<br>unique 相同的回调函数只能被添加一次<br>stopOnFalse 当有回调函数返回false时终止调用链的执行<br>CallbackS的控制方法：</p>
<p>callbacks.add() 添加一个或一串回调函数<br>callbacks.fire() 激发回调<br>callbacks.remove() 从调用链中移除指定的函数<br>callbacks.empty() 清空调用链<br>callbacks.disable() 关闭调用链的继续执行，新添加的函数也不会被执行<br>callbacks.lock() 锁定调用链，但是如果打开了memory的flag，新添加的函数仍然会执行<br>callbacks.has() 检查一个函数是否处于回调链之中<br>callbacks.fired() 检查回调链是否被激发<br>callbacks.locked() 检查回调链是否被锁定</p>

        </section>
    </article>
    
    
        <!-- livere 评论框 start -->
        <div class="comment">
            <div id="lv-container" data-id="city" data-uid="your_livere_uid"></div>
        </div>
        <!-- livere 评论框 end -->
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery选择器"><span class="toc-number">1.</span> <span class="toc-text">jQuery选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常规选择器"><span class="toc-number">1.1.</span> <span class="toc-text">常规选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性选择器"><span class="toc-number">1.2.</span> <span class="toc-text">属性选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控件选择器"><span class="toc-number">1.3.</span> <span class="toc-text">控件选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他选择器"><span class="toc-number">1.4.</span> <span class="toc-text">其他选择器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#节点漫游"><span class="toc-number">2.</span> <span class="toc-text">节点漫游</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#调用链处理"><span class="toc-number">2.1.</span> <span class="toc-text">调用链处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#子节点"><span class="toc-number">2.2.</span> <span class="toc-text">子节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#兄弟节点"><span class="toc-number">2.3.</span> <span class="toc-text">兄弟节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#父节点"><span class="toc-number">2.4.</span> <span class="toc-text">父节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#元素控制"><span class="toc-number">3.</span> <span class="toc-text">元素控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#attributes和properties的区别"><span class="toc-number">3.1.</span> <span class="toc-text">attributes和properties的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类与属性控制"><span class="toc-number">3.2.</span> <span class="toc-text">类与属性控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#样式控制"><span class="toc-number">3.3.</span> <span class="toc-text">样式控制</span></a></li></ol></li></ol>
        </div>
    </div>
    
  </aside>
</main>


<script type="text/javascript">
  (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];

      if (typeof LivereTower === 'function') { return; }

      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;

      e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>


  <footer id="fooler">
  <div class="copyright">
    <div>
      <span style="padding-right:30px;">
      &copy; 2018 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </span>
      
       本站总访客数 : <span id="busuanzi_value_site_uv"></span>人次 |
       本站总访问量 : <span id="busuanzi_value_site_pv"></span>次
      

    </div>
    <div>
      <!-- Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a> -->
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>

<script src="/js/script.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});

  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");

      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.1.20/jquery.fancybox.min.js"></script> -->



<div class="nodisplay">
<script src="https://s22.cnzz.com/z_stat.php?id=1272859133&web_id=1272859133" language="JavaScript"></script>
</div>



  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



</body>
</html>
